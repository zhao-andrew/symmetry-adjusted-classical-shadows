#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import itertools
import random

from openfermion.ops import MajoranaOperator
from openfermion.transforms import jordan_wigner, bravyi_kitaev

from FGU_random_cover import perm_parity, rand_alt_perm

#%% Functions for measurement counts

def rand_pauli_string(n):
    """
    Generates a random full-weight (n-qubit) Pauli string.
    """
    
    bases = ['X','Y','Z']
    
    P = []
    
    for i in range(n):
        P.append(random.sample(bases, 1)[0])
    
    return P

def permute_majorana_NC(indices, u):
    """
    Permutes a 2k-length set of Majorana indices with an n-length permutation
    u, consistent with the definition of Majorana operators and the fermionic
    swap unitary generated by u.

    Parameters
    ----------
    indices : iterable
        Input Majorana indices (subset of {0, ..., 2n-1}).
    u : iterable
        A permutation of {0, ..., n-1}.

    Returns
    -------
    tuple, int
        The permuted Majorana indices and the sign of the resulting operator
        (with respect to the canonical ascending-indices ordering).

    """
    
    assert len(indices) % 2 == 0
    assert len(indices) <= len(u)
    
    l = []
    for i in indices:
        if i % 2:
            l.append(int(2*u[(i-1)//2] + 1))
        else:
            l.append(int(2*u[i//2]))
    
    sign = (-1)**perm_parity(l)
    l.sort()
    
    return tuple(l), sign

def tally_pauli_matches(ops_dict, map_dict, u, pauli_measurement):
    """
    Tallies which observables in obs_dict are measured by a given fermionic
    swap unitary (generated by u) + n-qubit Pauli measurement
    (pauli_measurement). Updates ops_dict in-place and returns a list of the
    observables which are measured by this circuit.
    
    For speed, this function requires a dictionary map_dict which is of the
    form {(majorana_indices) : (pauli_string)} as determined by a chosen
    fermion-to-qubit mapping. We do not verify that map_dict is compatible with
    ops_dict, nor that the mapping was implemented correctly. Pauli strings
    take the OpenFermion convention for QubitOperator.

    Parameters
    ----------
    ops_dict : dict
        Dictionary of observables we wish to measure. Formatted as
        {indices : number of times tallied}. Note that the indices must be
        sorted (ascending).
        The goal is to run this function many times until all tallies are at
        least r, where r is a user-determined hyperparameter.
    map_dict : dict
        Precomputed dictionary of fermion-to-qubit mappings for all Majorana
        indices in ops_dict. Pauli strings are expressed using OpenFermion
        convention.
    u : iterable
        A permutation of {0, ..., n-1}.
    pauli_measurement : list
        The full-weight Pauli basis to measure in.

    Returns
    -------
    measured_ops : list
        A list of the operators which are measured (diagonalized) by the
        measurement circuit. They are organized as a tuple, (Majorana, diagonal
        Pauli, sign), where
        
        V U(u) (Majorana) U(u)^\dagger V^\dagger = sign * (diagonal Pauli).
        
        V is the layer of single-qubit Clifford gates which rotates into the
        basis of pauli_measurement.

    """
    
    measured_ops = []
    
    for mu in ops_dict:
        
        permuted_mu, sign = permute_majorana_NC(mu, u)
        permuted_mu_pauli = map_dict[permuted_mu]
        
        if all(P[1] == pauli_measurement[P[0]] for P in permuted_mu_pauli):
            ops_dict[mu] += 1
            measured_ops.append((mu, permuted_mu_pauli, sign))
    
    return measured_ops

def majorana_to_pauli_dict(majorana_list, qubit_mapping='jw'):
    """
    Generates a dictionary from Majorana operator indices (ordered tuples) to
    its Pauli string representation under a given fermion-to-qubit mapping.
    Does not keep track of phases in front of the operators, since they are
    always related by
    
    (-i)^k * Majorana = (+1) * Pauli,
    
    where the Majorana operator is of degree 2k.

    Parameters
    ----------
    majorana_list : iterable
        An iterable of Majorana tuples.
    qubit_mapping : str, optional
        The chosen fermion-to-qubit mapping, Jordan-Wigner ('jw') or Bravyi-
        Kitaev ('bk'). The default is 'jw'.

    Raises
    ------
    NotImplementedError
        If mappings other than Jordan-Wigner or Bravyi-Kitaev are specified.

    Returns
    -------
    majorana_to_pauli : dict
        Dictionary which maps between the Majorana and Pauli representations.

    """
    
    majorana_to_pauli = {}
    
    for majorana in majorana_list:
        
        if qubit_mapping == 'jw':
            op = jordan_wigner(MajoranaOperator(mu))
        elif qubit_mapping == 'bk':
            op = bravyi_kitaev(MajoranaOperator(mu))
        else:
            raise NotImplementedError(
                'Only jw and bk mappings currently supported.')
        
        majorana_to_pauli[majorana] = next(iter(op.terms))
    
    return majorana_to_pauli

def construct_random_measurements_NC(ops_dict, map_dict, n, r=10):
    """
    Constructs a random cover of ops_dict using the hyperparameter r. That is,
    it generates random (n-permutations + Pauli measurements) until all
    Majorana operators in ops_dict have been accounted for at least r times.

    Parameters
    ----------
    ops_dict : dict
        Dictionary of Majorana operators which we wish to measure. {key : val}
        pattern should be {(majorana_indices) : number_of_times_accounted_for}.
    map_dict : dict
        Precomputed dictionary of fermion-to-qubit mappings for all Majorana
        indices in ops_dict. Pauli strings are expressed using OpenFermion
        convention.
    n : int
        Number of qubits (currently only supports fermion-to-qubit encodings
        wwhich map n orbitals to n qubits).
    r : int, optional
        The minimum number of times each operator must be covered until the
        function halts. The default is 10.

    Returns
    -------
    random_measurements : dict
        The resulting cover of Majorana operators. The dictionary pattern is
        {(permutation, pauli_measurement) : [(measured_op_indices, sign)]}.

    """
    random_measurements = {}
    
    while any(counts < r for counts in ops_dict.values()):
        u = rand_alt_perm(n)
        pauli_measurement = rand_pauli_string(n)
        if (u, pauli_measurement) in random_measurements:
            continue
        
        measured_ops = tally_pauli_matches(ops_dict, map_dict, u,
                                           pauli_measurement)
        
        if len(measured_ops) > 0:
            random_measurements[(u, pauli_measurement)] = measured_ops
    
    return random_measurements

#%% Example

n = 6
k = 2

majorana_k_rdm_counts = {}

for j in range(1, k+1):
    for mu in itertools.combinations(range(2*n), 2*j):
        majorana_k_rdm_counts[mu] = 0

jw_mapping = majorana_to_pauli_dict(majorana_k_rdm_counts.keys(),
                                    qubit_mapping='jw')

rand_meas = construct_random_measurements_NC(majorana_k_rdm_counts, jw_mapping,
                                             n, r=10)
